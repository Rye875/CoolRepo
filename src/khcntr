 #This will have Gaussian Blur, Contour Detectin, etc

import cv2
from time import sleep
import numpy as np
from picamera2 import Picamera2
import serial
import RPi.GPIO as GPIO

if __name__ == '__main__':

#    GPIO.setwarnings(False)
#    GPIO.setmode(GPIO.BOARD)
#    GPIO.setup(5, GPIO.IN, pull_up_down=GPIO.PUD_UP)

    ''' #Test later in order to see how the button works
        while(True):
        if GPIO.input(5) == GPIO.LOW: #wait for button to be pressed
            break
    '''

    #Intializing the camera
    picam2 = Picamera2()
    picam2.preview_configuration.main.size = (640,480)
    picam2.preview_configuration.main.format = "RGB888"
    picam2.preview_configuration.align()
    picam2.configure("preview")
    picam2.start()
    width = 640
    height = 480
    pg = 0.25 #proportional gain
    kp = 0.02
    angle = 2090
    #points = [(115,100), (525,100), (640,470), (0,470)]

    points = [(0,0),(640,0),(640,480),(0,480)]
    color = (0, 255, 255) #yellow
    thickness = 4 #line thickness
    ser = serial.Serial('/dev/ttyACM0', 115200, timeout = 1) #approximately 57600 characters per second
    ser.flush()
    sleep(8)	
    
    
    speed = 1500 #faster speed to accelerate
    ser.write((str(speed) + "\n").encode('utf-8'))

    while True:
        im= picam2.capture_array()

        '''
        line1 = cv2.line(im, points[0], points[1], color, thickness)
        line2 = cv2.line(im, points[1], points[2], color, thickness)
        line3 = cv2.line(im, points[2], points[3], color, thickness)
        line4 = cv2.line(im, points[3], points[0], color, thickness)

        #cv2.imshow("ROI", im)

        ''' 

        input = np.float32(points)
        output = np.float32([(0,0), (width-1, 0), (width-1,height-1), (0, height-1)])

        matrix = cv2.getPerspectiveTransform(input,output)
        imgPerspective = cv2.warpPerspective(im, matrix, (width, height),
                                            cv2.INTER_LINEAR, borderMode=cv2.BORDER_CONSTANT, borderValue=(0,0,0))
    #cv2.imshow("Perspective", imgPerspective)
        #im = imgPerspective



        # Find contours in the edge image
        imgGray = cv2.cvtColor(imgPerspective, cv2.COLOR_BGR2GRAY)
        ret, imgThresh = cv2.threshold(imgGray, 35, 255, cv2.THRESH_BINARY_INV)
        #cv2.imshow("thres", imgThresh)

        # First coord is top left, second coord is bottom right.
        
        lft = [[20,330],[220,440]]

        right = [[430,330],[620,440]]

        contoursLeft, _ = cv2.findContours(imgThresh[lft[0][1]:lft[1][1],lft[0][0]:lft[1][0]], cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        contoursRight, _ = cv2.findContours(imgThresh[right[0][1]:right[1][1],right[0][0]:right[1][0]], cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        #contours, _ = cv2.findContours(imgThresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        #print(contours[1])
        #contours =  map(lambda c: c + lft[0],contours)

        # Offset based off topleft corner of each left/right rectrangle
        contoursLeft = [ c + lft[0] for c in contoursLeft]
        contoursRight = [ c + right[0] for c in contoursRight]
       

        # Draw contours on the original image
        cv2.drawContours(im, contoursLeft, -1, (0, 255, 0), 2)
        cv2.drawContours(im, contoursRight, -1, (0, 255, 0), 2)
     
        lftRectColor = (255,0,0) # Blue for "Off"
        rtRectColor = (255,0,0) # Blue for "Off"
       
        lftTot = 0
        for c in contoursLeft:
            lftTot += cv2.contourArea(c)

        rtTot = 0
        for c in contoursRight:
            rtTot += cv2.contourArea(c)
         
        error = lftTot-rtTot
        if error > 500:
            steering = kp * error
            if steering > 45:
                steering = 45
            elif steering < -45:
                steering = -45
            angle = 2090 + steering
        sleep(0.1)
        print(angle)
        angle = int(angle)
        ser.write((str(angle) + "\n").encode('utf-8'))
        #lft = map(int,lft)
        #right = map(int,right)
        cv2.rectangle(im,tuple(lft[0]),tuple(lft[1]),lftRectColor,2)
        cv2.rectangle(im,tuple(right[0]),tuple(right[1]),rtRectColor,2)
        cv2.putText(im,str(lftTot),(lft[0][0],lft[0][1]-5),cv2.FONT_HERSHEY_SIMPLEX,1,lftRectColor,2,cv2.LINE_AA)
        cv2.putText(im,str(rtTot),(right[0][0],right[0][1]-5),cv2.FONT_HERSHEY_SIMPLEX,1,rtRectColor,2,cv2.LINE_AA)
        cv2.putText(im,str(angle),(lft[0][0]-20,right[0][1]-50),cv2.FONT_HERSHEY_SIMPLEX,1,lftRectColor,2,cv2.LINE_AA)

        #speed = 1000
     #   px.forward(speed)


        #imgCanny2 = cv2.Canny(imgGray, lowThresh, highThresh)
        #cv2.imshow("canny without gaussian blur", imgCanny2)

        #imgFinal = imgGray
        cv2.imshow("Thresh", imgThresh)

        # Display the original image with contours
        cv2.imshow("Contours", im)

        if cv2.waitKey(1)==ord('q'):#wait until key ‘q’ pressed
            ser.flush()
            speed = 1500
            ser.write((str(speed) + "\n").encode('utf-8'))
            angle = 2090
            ser.write((str(angle) + "\n").encode('utf-8'))
            break
    cv2.destroyAllWindows()
#final 2
